---
title: 关于继承
date: 2019-12-12 15:25:20
tags:
---
**对象的组合优于类的继承**

类之间合理使用继承，适当时候可以使用对象的组合来代替类的继承。

当一个对象的行为有明显的类别之分时，继承是一种很自然的表达方式。

实现过程中，将可以共用的数据和行为都放在超类中，各个子类再根据需要重写覆盖部分特性。


子类为数据结构的多样性和行为的多态化提供了很好的支持，是针对差异性编程的好工具。

一旦使用了继承，那么父类和子类之间就有了紧密联系，特别是当父类发生修改时会影响所有的子类。

## 继承
子类通过继承的方式来获得超类的所有功能。

## 继承的2个判定要点
子类必须可以适用超类的所有函数。
子类的所有实例必须都是超类的实例，都可以通过超类的接口来使用子类的实例。
<!--more-->

## 典型的错误例子 
* Stack extends List 栈继承于列表

> 栈只是想复用列表的数据存储和操作能力
> 列表提供的所有操作都会出现在栈上，但是大部分操作却并不适合栈。
> 改进策略：将列表作为栈的内部成员，将栈需要的操作转移到列表上，而非直接继承。
宿主类是原来的子类，委托类是原来的超类，在子类中将对应的操作转发给委托类去执行即可。

## 典型的有效例子
* 设计模式中State状态模式和Strategy策略模式

> 两种设计模式都是将本该由宿主对象的子类来处理的事情转发给其他对象来取代原来的继承。
> 更为优雅地将switch或if进行了转换。

更好地抽象了 共同点和变化点，保留共同点，抽象变化点。

对修改关闭，对扩展开放。

Replace Subclass with Field && Replace Field with subclass

超类的工厂函数 有很好的作用。

为每个构造函数分别创建一个工厂函数
```
function createPerson(name){
    return new Person(name)
}

function createMale(name){
    return new Male(name)
}

function createFemale(name){
    return new Female(name)
}
```


## SOLID
* 单一职责
* 开放封闭职责
* 里式替换职责
* 依赖倒置职责
* 接口隔离职责

抽象类 & 接口

继承 & 组合



